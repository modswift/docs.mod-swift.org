{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mod_swift Documentation mod_swift allows you to write native modules for the Apache Web Server in the Swift 3 programming language. That is without any proxies, interpreters or other hacks - fully integrated, compiled Apache modules that can do anything a C module could do. Server Side Swift the right way. What is an Apache module? Apache is a highly modular and efficient server framework. The httpd daemon itself is quite tiny and pretty much all webserver functionality is actually implemented in the form of modules . Be it thread handling, access control, mime detection or content negotation - all of that is implemented as modules. And can be replaced by own modules! The Apache core modules are written in portable C. Some modules are built right into the server, but most are loaded as dynamic libraries . Which ones is specified by the user in the configuration file , for example: LoadModule authz_core_module /usr/libexec/apache2/mod_authz_core.so LoadModule mime_module /usr/libexec/apache2/mod_mime.so Now with mod_swift you can write such modules using the Swift programming language. Enter: LoadSwiftModule ApacheMain /usr/libexec/apache2/mods_demo.so This is a little different to something like mod_php which enables Apache to directly interpret PHP scripts. mod_php itself is C software and a single module. Since Swift compiles down to regular executable binaries, and because Swift has excellent C integration , you can write arbitrary modules with mod_swift which behave just like the regular C modules.","title":"Introduction"},{"location":"#mod_swift-documentation","text":"mod_swift allows you to write native modules for the Apache Web Server in the Swift 3 programming language. That is without any proxies, interpreters or other hacks - fully integrated, compiled Apache modules that can do anything a C module could do. Server Side Swift the right way.","title":"mod_swift Documentation"},{"location":"#what-is-an-apache-module","text":"Apache is a highly modular and efficient server framework. The httpd daemon itself is quite tiny and pretty much all webserver functionality is actually implemented in the form of modules . Be it thread handling, access control, mime detection or content negotation - all of that is implemented as modules. And can be replaced by own modules! The Apache core modules are written in portable C. Some modules are built right into the server, but most are loaded as dynamic libraries . Which ones is specified by the user in the configuration file , for example: LoadModule authz_core_module /usr/libexec/apache2/mod_authz_core.so LoadModule mime_module /usr/libexec/apache2/mod_mime.so Now with mod_swift you can write such modules using the Swift programming language. Enter: LoadSwiftModule ApacheMain /usr/libexec/apache2/mods_demo.so This is a little different to something like mod_php which enables Apache to directly interpret PHP scripts. mod_php itself is C software and a single module. Since Swift compiles down to regular executable binaries, and because Swift has excellent C integration , you can write arbitrary modules with mod_swift which behave just like the regular C modules.","title":"What is an Apache module?"},{"location":"about/","text":"Apache modules in Swift . Contact Hey, we love feedback. Join the mailing list, Slack channel or just drop us an email to tell us why this is crap (or not?). Mailing List Slack info@mod-swift.org Mkdocs Built with MkDocs using a theme provided by Read the Docs . Who mod_swift is brought to you by the ZeeZide GmbH. Imprint .","title":"About"},{"location":"about/#contact","text":"Hey, we love feedback. Join the mailing list, Slack channel or just drop us an email to tell us why this is crap (or not?). Mailing List Slack info@mod-swift.org","title":"Contact"},{"location":"about/#mkdocs","text":"Built with MkDocs using a theme provided by Read the Docs .","title":"Mkdocs"},{"location":"about/#who","text":"mod_swift is brought to you by the ZeeZide GmbH. Imprint .","title":"Who"},{"location":"apacheexpress/","text":"ApacheExpress ApacheExpress is a framework layering on top of mod_swift. It makes it very easy to quickly build reliable and feature rich Swift server applications from within Xcode or using the Swift Package Manager. It supports convenient database access using Apache mod_dbd. And well, can be used together with all the other regular Apache modules you know and love. Example: public func ApacheMain(_ cmd: OpaquePointer) { let app = ApacheExpress.express(cmd) app.use(cookieParser()) app.get(\"/cookies.json\") { req, res, next in try res.json(req.cookies) } app.get(\"/\") { req, res, next in let values : [ String : Any ] = [ \"cowOfTheDay\" : cows.vaca() ] try res.render(\"index\", values) } } ApacheExpress Homepage ApacheExpress Documentation","title":"ApacheExpress"},{"location":"apacheexpress/#apacheexpress","text":"ApacheExpress is a framework layering on top of mod_swift. It makes it very easy to quickly build reliable and feature rich Swift server applications from within Xcode or using the Swift Package Manager. It supports convenient database access using Apache mod_dbd. And well, can be used together with all the other regular Apache modules you know and love. Example: public func ApacheMain(_ cmd: OpaquePointer) { let app = ApacheExpress.express(cmd) app.use(cookieParser()) app.get(\"/cookies.json\") { req, res, next in try res.json(req.cookies) } app.get(\"/\") { req, res, next in let values : [ String : Any ] = [ \"cowOfTheDay\" : cows.vaca() ] try res.render(\"index\", values) } } ApacheExpress Homepage ApacheExpress Documentation","title":"ApacheExpress"},{"location":"configtemplates/","text":"Apache Configuration Templates mod_swift does not require any configuration. Within your Apache module, you can just run swift apache serve and it'll derive a configuration from the module setup (i.e. issue proper LoadModule directives, configure a document root, HTTP/2 and so on). However, if you desire, you can tweak that process using mod_swift configuration templates. Configuration Templates System Templates The global Apache configuration is derived from the templates installed in {install-prefix}/lib/mod_swift/apache-config-templates/ . It contains debug/release versions as well as versions for macOS Homebrew and Ubuntu. Full Override: apache.conf If you don't want any auto-configuration by swift apache serve , you can place a file called apache.conf into your module directory. If that exists, no configuration templating will happen, it is all up to you. Custom Templates If the module directory contains a apache-template.conf , that is going to be used instead of the System Templates mentioned above. Either that or a system template is used as the basis. If it doesn't contain a LoadModule swift_module , that will get attached next. In the next step the configuration will check for {modulename}.conf and {modulename}-template.conf within your Swift Apache module directory. For example mods_helloworld-template.conf . One of the two is a good place to do additional configuration. Example Template A config template is a great way to configure Apache mod_dbd for the module. If the module is called mods_testdb , create a new file called mods_testdb-template.conf with the necessary database configuration. For example to configure Apache to access a SQLite3 database living within the data directory of your module source: LoadModule dbd_module %APACHE_MODULE_DIR%/mod_dbd.so <IfModule dbd_module> DBDriver sqlite3 DBDParams \"%SRCROOT%/data/MyDatabase.sqlite3\" </IfModule> Note how the %APACHE_MODULE_DIR% variable is used to refer to the module location. Also note how %SRCROOT% is used to refer to the SQLite3 database file. This is necessary, because mod_dbd requires an absolute path to the database file (i.e. a relative path like \"data/MyDatabase.sqlite3\" doesn't work). Template Variables %SRCROOT% %APACHE_PREFIX% %APACHE_PORT% %APACHE_SSL_PORT% %APACHE_PIDFILE% %APACHE_DOCROOT% %APACHE_MODULE_RELDIR% %APACHE_MODULE_DIR% %APACHE_SERVER_CERT_DIR% %APACHE_SERVER_CERT% %APACHE_SERVER_KEY% %APACHE_HTTP2_LOAD_COMMAND% %CONFIGURATION_BUILD_DIR% Document Root Lookup mod_swift will look into the SRCROOT of the package and check for the availability of those directories: htdocs/ www/ public/ So within modules, you can just create a public directory, and Apache will be configured to serve static files from there. If none of those directories are available, it'll use whatever apxs -q htdocsdir has as the document root.","title":"Configuration Templates"},{"location":"configtemplates/#apache-configuration-templates","text":"mod_swift does not require any configuration. Within your Apache module, you can just run swift apache serve and it'll derive a configuration from the module setup (i.e. issue proper LoadModule directives, configure a document root, HTTP/2 and so on). However, if you desire, you can tweak that process using mod_swift configuration templates.","title":"Apache Configuration Templates"},{"location":"configtemplates/#configuration-templates","text":"","title":"Configuration Templates"},{"location":"configtemplates/#system-templates","text":"The global Apache configuration is derived from the templates installed in {install-prefix}/lib/mod_swift/apache-config-templates/ . It contains debug/release versions as well as versions for macOS Homebrew and Ubuntu.","title":"System Templates"},{"location":"configtemplates/#full-override-apacheconf","text":"If you don't want any auto-configuration by swift apache serve , you can place a file called apache.conf into your module directory. If that exists, no configuration templating will happen, it is all up to you.","title":"Full Override: apache.conf"},{"location":"configtemplates/#custom-templates","text":"If the module directory contains a apache-template.conf , that is going to be used instead of the System Templates mentioned above. Either that or a system template is used as the basis. If it doesn't contain a LoadModule swift_module , that will get attached next. In the next step the configuration will check for {modulename}.conf and {modulename}-template.conf within your Swift Apache module directory. For example mods_helloworld-template.conf . One of the two is a good place to do additional configuration.","title":"Custom Templates"},{"location":"configtemplates/#example-template","text":"A config template is a great way to configure Apache mod_dbd for the module. If the module is called mods_testdb , create a new file called mods_testdb-template.conf with the necessary database configuration. For example to configure Apache to access a SQLite3 database living within the data directory of your module source: LoadModule dbd_module %APACHE_MODULE_DIR%/mod_dbd.so <IfModule dbd_module> DBDriver sqlite3 DBDParams \"%SRCROOT%/data/MyDatabase.sqlite3\" </IfModule> Note how the %APACHE_MODULE_DIR% variable is used to refer to the module location. Also note how %SRCROOT% is used to refer to the SQLite3 database file. This is necessary, because mod_dbd requires an absolute path to the database file (i.e. a relative path like \"data/MyDatabase.sqlite3\" doesn't work).","title":"Example Template"},{"location":"configtemplates/#template-variables","text":"%SRCROOT% %APACHE_PREFIX% %APACHE_PORT% %APACHE_SSL_PORT% %APACHE_PIDFILE% %APACHE_DOCROOT% %APACHE_MODULE_RELDIR% %APACHE_MODULE_DIR% %APACHE_SERVER_CERT_DIR% %APACHE_SERVER_CERT% %APACHE_SERVER_KEY% %APACHE_HTTP2_LOAD_COMMAND% %CONFIGURATION_BUILD_DIR%","title":"Template Variables"},{"location":"configtemplates/#document-root-lookup","text":"mod_swift will look into the SRCROOT of the package and check for the availability of those directories: htdocs/ www/ public/ So within modules, you can just create a public directory, and Apache will be configured to serve static files from there. If none of those directories are available, it'll use whatever apxs -q htdocsdir has as the document root.","title":"Document Root Lookup"},{"location":"http2/","text":"HTTP/2 If your server provides the mod_http2 module, swift apache will automatically pick it up, configure a development SSL certificate and the HTTP/2 module. Check whether HTTP/2 is available To check whether mod_swift did detect the HTTP/2 module successfully, you can run: $ swift apache validate The Swift Apache build environment looks sound. srcroot: /Users/helge/tmp/tests/mods_helloworld module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift swift: 3.0.2 cert: self-signed-mod_swift-localhost-server.crt http/2: yes Look for the last line and check whether it says yes . Install the Homebrew Apache w/ HTTP/2 Before you install mod_swift, we highly recommend that you install or reinstall the Homebrew Apache w/ HTTP/2 and the MPM event module: brew reinstall httpd --with-mpm-event --with-http2 You can also add --with-privileged-ports if you want to use such. Useful tools Chrome Developer Tools You can use the Network tab in the Chrome Developer Tools to check whether requests are done using HTTP/2. Right click the table view and select 'Protocol'. curl w/ HTTP/2 support On Homebrew you can easily install curl with HTTP/2 support: brew reinstall curl --with-nghttp2 --with-openssl IMPORTANT : curl is Cellar only w/ Homebrew. To invoke it either adjust your PATH to include /use/local/opt/curl/bin or invoke curl with the full path: /usr/local/opt/curl/bin/curl -v --insecure --http2 https://localhost:8442/hello (--insecure is needed if you use it w/ the self-signed certificate coming w/ mod_swift) You can scan the output of curl to see whether it is actually using HTTP/2: ... * ALPN, offering h2 * ALPN, offering http/1.1 ... * Using HTTP2, server supports multi-use * Connection state changed (HTTP/2 confirmed) ... > GET /hello HTTP/2 ... < HTTP/2 200 ... Links how to h2 in apache","title":"HTTP/2"},{"location":"http2/#http2","text":"If your server provides the mod_http2 module, swift apache will automatically pick it up, configure a development SSL certificate and the HTTP/2 module.","title":"HTTP/2"},{"location":"http2/#check-whether-http2-is-available","text":"To check whether mod_swift did detect the HTTP/2 module successfully, you can run: $ swift apache validate The Swift Apache build environment looks sound. srcroot: /Users/helge/tmp/tests/mods_helloworld module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift swift: 3.0.2 cert: self-signed-mod_swift-localhost-server.crt http/2: yes Look for the last line and check whether it says yes .","title":"Check whether HTTP/2 is available"},{"location":"http2/#install-the-homebrew-apache-w-http2","text":"Before you install mod_swift, we highly recommend that you install or reinstall the Homebrew Apache w/ HTTP/2 and the MPM event module: brew reinstall httpd --with-mpm-event --with-http2 You can also add --with-privileged-ports if you want to use such.","title":"Install the Homebrew Apache w/ HTTP/2"},{"location":"http2/#useful-tools","text":"","title":"Useful tools"},{"location":"http2/#chrome-developer-tools","text":"You can use the Network tab in the Chrome Developer Tools to check whether requests are done using HTTP/2. Right click the table view and select 'Protocol'.","title":"Chrome Developer Tools"},{"location":"http2/#curl-w-http2-support","text":"On Homebrew you can easily install curl with HTTP/2 support: brew reinstall curl --with-nghttp2 --with-openssl IMPORTANT : curl is Cellar only w/ Homebrew. To invoke it either adjust your PATH to include /use/local/opt/curl/bin or invoke curl with the full path: /usr/local/opt/curl/bin/curl -v --insecure --http2 https://localhost:8442/hello (--insecure is needed if you use it w/ the self-signed certificate coming w/ mod_swift) You can scan the output of curl to see whether it is actually using HTTP/2: ... * ALPN, offering h2 * ALPN, offering http/1.1 ... * Using HTTP2, server supports multi-use * Connection state changed (HTTP/2 confirmed) ... > GET /hello HTTP/2 ... < HTTP/2 200 ...","title":"curl w/ HTTP/2 support"},{"location":"http2/#links","text":"how to h2 in apache","title":"Links"},{"location":"install/","text":"mod_swift Installation mod_swift should install fine on pretty much any Unix system that can run Swift and Apache 2.4. Including exotic setups like Raspberry Pi systems. We also provide a macOS Homebrew tap which makes it really easy to install mod_swift and its dependencies on macOS. We highly recommend that over a custom install. On the Linux side we test w/ Ubuntu Trusty and Xenial, though it should work pretty much anywhere. Install on macOS using Homebrew Got no Homebrew? Get it! Before you install mod_swift, we highly recommend that you install or reinstall the Homebrew Apache w/ HTTP/2 and the MPM event module: brew reinstall httpd --with-mpm-event --with-http2 You can also add --with-privileged-ports if you want to use such. Then add the mod_swift tap and install mod_swift: brew tap modswift/mod_swift brew install mod_swift (yes, the account is just modswift w/o underscore due to GitHub limitations) Install on Linux (or macOS w/o Homebrew) On macOS: We strongly advise that you rather use Homebrew, more importantly the Apache provided by Homebrew. Ubuntu packages required (assuming you have Swift 3 installed already), this includes the PostgreSQL and SQLite3 database adaptors, add additional ones as desired: sudo apt-get update sudo apt-get install \\ curl pkg-config libapr1-dev libaprutil1-dev \\ libxml2 apache2 apache2-dev \\ libnghttp2-dev \\ libaprutil1-dbd-sqlite3 \\ libaprutil1-dbd-pgsql Install mod_swift: curl -L -o mod_swift.tgz \\ https://github.com/modswift/mod_swift/archive/0.9.0.tar.gz tar zxf mod_swift.tgz && cd mod_swift-0.9.0 make sudo make install That puts mod_swift into /usr/local . If you want to have it in /usr , do: sudo make prefix=/usr install Check whether the installation is OK You can call swift apache validate to make sure the installation is OK: $ swift apache validate The Swift Apache build environment looks sound. srcroot: /Users/helge/dev/Swift/Apex3 module: mods_Apex3 config: debug product: /Users/helge/dev/Swift/Apex3/.build/mods_Apex3.so apxs: /usr/local/bin/apxs mod_swift: /usr/local swift: 5.0.1 cert: self-signed-mod_swift-localhost-server.crt http/2: yes Troubleshooting If something isn't working in a Homebrew setup, check whether: brew doctor outputs anything unusual. If you need any help, feel free to ask on the Mailing List or our Slack channel .","title":"Installation"},{"location":"install/#mod_swift-installation","text":"mod_swift should install fine on pretty much any Unix system that can run Swift and Apache 2.4. Including exotic setups like Raspberry Pi systems. We also provide a macOS Homebrew tap which makes it really easy to install mod_swift and its dependencies on macOS. We highly recommend that over a custom install. On the Linux side we test w/ Ubuntu Trusty and Xenial, though it should work pretty much anywhere.","title":"mod_swift Installation"},{"location":"install/#install-on-macos-using-homebrew","text":"Got no Homebrew? Get it! Before you install mod_swift, we highly recommend that you install or reinstall the Homebrew Apache w/ HTTP/2 and the MPM event module: brew reinstall httpd --with-mpm-event --with-http2 You can also add --with-privileged-ports if you want to use such. Then add the mod_swift tap and install mod_swift: brew tap modswift/mod_swift brew install mod_swift (yes, the account is just modswift w/o underscore due to GitHub limitations)","title":"Install on macOS using Homebrew"},{"location":"install/#install-on-linux-or-macos-wo-homebrew","text":"On macOS: We strongly advise that you rather use Homebrew, more importantly the Apache provided by Homebrew. Ubuntu packages required (assuming you have Swift 3 installed already), this includes the PostgreSQL and SQLite3 database adaptors, add additional ones as desired: sudo apt-get update sudo apt-get install \\ curl pkg-config libapr1-dev libaprutil1-dev \\ libxml2 apache2 apache2-dev \\ libnghttp2-dev \\ libaprutil1-dbd-sqlite3 \\ libaprutil1-dbd-pgsql Install mod_swift: curl -L -o mod_swift.tgz \\ https://github.com/modswift/mod_swift/archive/0.9.0.tar.gz tar zxf mod_swift.tgz && cd mod_swift-0.9.0 make sudo make install That puts mod_swift into /usr/local . If you want to have it in /usr , do: sudo make prefix=/usr install","title":"Install on Linux (or macOS w/o Homebrew)"},{"location":"install/#check-whether-the-installation-is-ok","text":"You can call swift apache validate to make sure the installation is OK: $ swift apache validate The Swift Apache build environment looks sound. srcroot: /Users/helge/dev/Swift/Apex3 module: mods_Apex3 config: debug product: /Users/helge/dev/Swift/Apex3/.build/mods_Apex3.so apxs: /usr/local/bin/apxs mod_swift: /usr/local swift: 5.0.1 cert: self-signed-mod_swift-localhost-server.crt http/2: yes","title":"Check whether the installation is OK"},{"location":"install/#troubleshooting","text":"If something isn't working in a Homebrew setup, check whether: brew doctor outputs anything unusual. If you need any help, feel free to ask on the Mailing List or our Slack channel .","title":"Troubleshooting"},{"location":"links/","text":"Apache Link Collection There is plenty of information on the Interwebs about \"The Number One HTTP Server On The Internet\": Official Apache Documentation The Apache HTTP Server Project User Guide Configuration Quick Reference Developer Documentation C Module Development Intro Books The Apache Modules Book Swift Apache Frameworks mod_swift ApacheExpress HTTP/2 how to h2 in apache","title":"Link Collection"},{"location":"links/#apache-link-collection","text":"There is plenty of information on the Interwebs about \"The Number One HTTP Server On The Internet\":","title":"Apache Link Collection"},{"location":"links/#official-apache-documentation","text":"The Apache HTTP Server Project User Guide Configuration Quick Reference Developer Documentation C Module Development Intro","title":"Official Apache Documentation"},{"location":"links/#books","text":"The Apache Modules Book","title":"Books"},{"location":"links/#swift-apache-frameworks","text":"mod_swift ApacheExpress","title":"Swift Apache Frameworks"},{"location":"links/#http2","text":"how to h2 in apache","title":"HTTP/2"},{"location":"mod_dbd/","text":"Database Access using mod_dbd 2019-08-14: Homebrew has removed support for apr-util DBD drivers: PR #31799 . Looks like one has to install Apache by hand for this feature. A feature of Apache 2 known to few is mod_dbd . Using that you can configure a SQL database connection within the Apache.conf and use that within all your Apache modules/handlers. Note : Shown below is pretty raw access to mod_dbd as provided by the mod_swift Apache wrapper module. You can use ApacheExpress to access databases using the ZeeQL library, which is way more convenient. This will setup a directory as a barebones Swift Apache module (try ApacheExpress for a higher level API!) Though you can also write your own, Apache 2 comes with drivers for SQLite3 , PostgreSQL , MySQL and Oracle. The macOS system Apache and the one than can be tapped in Homebrew includes SQLite3. On Linux you can easily install the ones you want: sudo apt-get install libaprutil1-dbd-sqlite3 libaprutil1-dbd-pgsql Your Swift Apache module doesn't need to concern itself with the database type or connection, it can just ask Apache for a connection and it'll happily return one from its pool. The code looks like this: guard let con = req.dbdAcquire() else { return ... } guard let res = con.select(\"SELECT * FROM pets\") else { return ... } while let row = res.next() { req.puts(\"<li>\\(row[0])</li>\") } So how does Apache know how to connect and all that? As everything in Apache, the admin can configure that in the apache.conf: <IfModule dbd_module> DBDriver sqlite3 DBDParams \"/var/data/testdb.sqlite3\" </IfModule> Or to access your favorite OpenGroupware.org database using PostgreSQL: <IfModule dbd_module> DBDriver pgsql DBDParams \"host=127.0.0.1 port=5432 dbname=OGo user=OGo password=OGo\" # Connection Pool Management DBDMin 1 DBDKeep 2 DBDMax 10 DBDExptime 60 </IfModule> You get the idea. We provide a simple wrapper for the select query shown as part of our Apache module.","title":"SQL Database Access"},{"location":"mod_dbd/#database-access-using-mod_dbd","text":"2019-08-14: Homebrew has removed support for apr-util DBD drivers: PR #31799 . Looks like one has to install Apache by hand for this feature. A feature of Apache 2 known to few is mod_dbd . Using that you can configure a SQL database connection within the Apache.conf and use that within all your Apache modules/handlers. Note : Shown below is pretty raw access to mod_dbd as provided by the mod_swift Apache wrapper module. You can use ApacheExpress to access databases using the ZeeQL library, which is way more convenient. This will setup a directory as a barebones Swift Apache module (try ApacheExpress for a higher level API!) Though you can also write your own, Apache 2 comes with drivers for SQLite3 , PostgreSQL , MySQL and Oracle. The macOS system Apache and the one than can be tapped in Homebrew includes SQLite3. On Linux you can easily install the ones you want: sudo apt-get install libaprutil1-dbd-sqlite3 libaprutil1-dbd-pgsql Your Swift Apache module doesn't need to concern itself with the database type or connection, it can just ask Apache for a connection and it'll happily return one from its pool. The code looks like this: guard let con = req.dbdAcquire() else { return ... } guard let res = con.select(\"SELECT * FROM pets\") else { return ... } while let row = res.next() { req.puts(\"<li>\\(row[0])</li>\") } So how does Apache know how to connect and all that? As everything in Apache, the admin can configure that in the apache.conf: <IfModule dbd_module> DBDriver sqlite3 DBDParams \"/var/data/testdb.sqlite3\" </IfModule> Or to access your favorite OpenGroupware.org database using PostgreSQL: <IfModule dbd_module> DBDriver pgsql DBDParams \"host=127.0.0.1 port=5432 dbname=OGo user=OGo password=OGo\" # Connection Pool Management DBDMin 1 DBDKeep 2 DBDMax 10 DBDExptime 60 </IfModule> You get the idea. We provide a simple wrapper for the select query shown as part of our Apache module.","title":"Database Access using mod_dbd"},{"location":"tools/","text":"mod_swift Tools mod_swift comes with a set of CLI tools that integrate with the Swift Package Manager. The tools enhance the Swift Package Manager to be able to build native Apache modules, configure them and run them. All of them are invoked like: swift apache <subcommand> If the toolname is omitted, you get a small help: $ swift apache usage: swift apache <subcommand> Available subcommands are: init Setup directory as a Swift Apache module Package. build Build Swift Package as a Swift module. serve Start Apache and load Swift Apache module. validate Check Apache build environment. Try 'swift apache <subcommand> help' for details. Note : ApacheExpress comes with its own set of tools. swift apache init Prepare a directory as a Swift Apache module. This will setup a directory as a barebones Swift Apache module (try ApacheExpress for a higher level API!) $ mkdir mods_helloworld && cd mods_helloworld $ swift apache init The Swift Apache build environment looks sound. module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift swift apache build swift apache build first invokes swift build and subsequently converts the build results into an Apache module shared library. $ swift apache build Cloning https://github.com/modswift/Apache.git HEAD is now at 37f3038 Travis: use `swift build` Resolved version: 0.2.0 Cloning https://github.com/modswift/CApache.git HEAD is now at aa7d5b5 Tabs to spaces Resolved version: 1.0.0 Compile Swift Module 'Apache' (8 sources) Compile Swift Module 'mods_helloworld' (1 sources) $ ls -hl .build/mods_helloworld.so -rwxr-xr-x 1 helge staff 240K May 30 16:05 .build/mods_helloworld.so swift apache serve The swift apache serve command will generate an Apache configuration and start Apache with it. You can then access your module in the browser using either HTTP: http://localhost:8042/ HTTPS / HTTP/2: https://localhost:8442/ $ swift apache serve Note: DocRoot /usr/local/var/www/htdocs Starting Apache on port 8042/8442: GET /helloworld/ 200 715 - 0ms You can modify the configuration which is created using mod_swift config templates . swift apache validate swift apache validate just checks whether a build is likely to be successful and prints out the configuration assumptions it has. $ swift apache validate The Swift Apache build environment looks sound. srcroot: /Users/helge/tmp/tests/mods_helloworld module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift swift: 3.0.2 cert: self-signed-mod_swift-localhost-server.crt http/2: yes","title":"Tools Reference"},{"location":"tools/#mod_swift-tools","text":"mod_swift comes with a set of CLI tools that integrate with the Swift Package Manager. The tools enhance the Swift Package Manager to be able to build native Apache modules, configure them and run them. All of them are invoked like: swift apache <subcommand> If the toolname is omitted, you get a small help: $ swift apache usage: swift apache <subcommand> Available subcommands are: init Setup directory as a Swift Apache module Package. build Build Swift Package as a Swift module. serve Start Apache and load Swift Apache module. validate Check Apache build environment. Try 'swift apache <subcommand> help' for details. Note : ApacheExpress comes with its own set of tools.","title":"mod_swift Tools"},{"location":"tools/#swift-apache-init","text":"Prepare a directory as a Swift Apache module. This will setup a directory as a barebones Swift Apache module (try ApacheExpress for a higher level API!) $ mkdir mods_helloworld && cd mods_helloworld $ swift apache init The Swift Apache build environment looks sound. module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift","title":"swift apache init"},{"location":"tools/#swift-apache-build","text":"swift apache build first invokes swift build and subsequently converts the build results into an Apache module shared library. $ swift apache build Cloning https://github.com/modswift/Apache.git HEAD is now at 37f3038 Travis: use `swift build` Resolved version: 0.2.0 Cloning https://github.com/modswift/CApache.git HEAD is now at aa7d5b5 Tabs to spaces Resolved version: 1.0.0 Compile Swift Module 'Apache' (8 sources) Compile Swift Module 'mods_helloworld' (1 sources) $ ls -hl .build/mods_helloworld.so -rwxr-xr-x 1 helge staff 240K May 30 16:05 .build/mods_helloworld.so","title":"swift apache build"},{"location":"tools/#swift-apache-serve","text":"The swift apache serve command will generate an Apache configuration and start Apache with it. You can then access your module in the browser using either HTTP: http://localhost:8042/ HTTPS / HTTP/2: https://localhost:8442/ $ swift apache serve Note: DocRoot /usr/local/var/www/htdocs Starting Apache on port 8042/8442: GET /helloworld/ 200 715 - 0ms You can modify the configuration which is created using mod_swift config templates .","title":"swift apache serve"},{"location":"tools/#swift-apache-validate","text":"swift apache validate just checks whether a build is likely to be successful and prints out the configuration assumptions it has. $ swift apache validate The Swift Apache build environment looks sound. srcroot: /Users/helge/tmp/tests/mods_helloworld module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift swift: 3.0.2 cert: self-signed-mod_swift-localhost-server.crt http/2: yes","title":"swift apache validate"},{"location":"usage/","text":"Hello World Note: mod_swift only provides a very low level raw API. If you want something more convenient, checkout ApacheExpress . But lets do a simple mods_helloworld module for demonstration purposes. Setup Module Setup a new directory and initialize it as an Apache Swift module: $ mkdir mods_helloworld && cd mods_helloworld $ swift apache init The Swift Apache build environment looks sound. module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift This creates a Swift Package Manager module and places an example Apache entry point into it: $ tree . \u251c\u2500\u2500 Package.swift \u2514\u2500\u2500 Sources \u2514\u2500\u2500 mods_helloworld \u2514\u2500\u2500 mods_helloworld.swift 2 directory, 2 files The Package.swift just loads the Apache wrapper module we provide: import PackageDescription let package = Package( name: \"mods_helloworld\", dependencies: [ .package(url: \"https://github.com/modswift/Apache.git\", from: \"0.5.0\") ], targets: [ .target(name: \"mods_helloworld\", dependencies: [ \"Apache\" ]) ] ) The mods_helloworld.swift source file contains a demo Apache module. The file can be named anything (but main.swift, which would produce a tool instead of a library ;-) import CApache import Apache var module = CApache.module(name: \"mods_helloworld\") func mods_helloworldHandler(p: UnsafeMutablePointer<request_rec>?) -> Int32 { // example content handler, modify to your liking var req = ApacheRequest(raw: p!) req.contentType = \"text/html; charset=ascii\" req.puts(\"<html><head><title>Hello mod_swift</title>\\(semanticUI)</head>\") req.puts(\"<body><div class='ui main container' style='margin-top: 1em;'>\") req.puts(\"<h3>Welcome to mods_helloworld</h3>\") defer { req.puts(\"</div></body></html>\") } req.puts(\"<h4>Links of Interest</h4>\") req.puts(\"<ul>\") req.puts(\" <li><a href='http://mod-swift.org/'>mod-swift.org</a></li>\") req.puts(\" <li><a href='http://apacheexpress.io/'>ApacheExpress</a></li>\") req.puts(\" <li><a href='https://httpd.apache.org/'>Apache</a></li>\") req.puts(\"</ul>\") return OK } fileprivate func register_hooks(pool: OpaquePointer?) { // hookup the handlers you want ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE) } @_cdecl(\"ApacheMain\") public func ApacheMain(cmd: UnsafeMutablePointer<cmd_parms>) { module.register_hooks = register_hooks let rc = apz_register_swift_module(cmd, &module) assert(rc == APR_SUCCESS, \"Could not add Swift module!\") } Explanation of the Source Module Structure At the top this prepares the Apache module structure. The structure identifies our module within Apache. It contains the name, links to our callbacks, and optionally configuration data (yes, you can also add your own configuration directives to the Apache config). var module = CApache.module(name: \"mods_helloworld\") Which is registered at the bottom, in the ApacheMain function: ApacheMain() ApacheMain is the primary entry point which is called by mod_swift when it executes the LoadSwiftModule directive in the Apache configuration. The @_cdecl isn't actually required in this case, but can be necessary in more complex setups. It tells Apache where to find the entry function (Apache being written in C, needs to have a C name, which often, but not always can be derived - the cdecl makes it explicit). @_cdecl(\"ApacheMain\") public func ApacheMain(cmd: UnsafeMutablePointer<cmd_parms>) { module.register_hooks = register_hooks let rc = apz_register_swift_module(cmd, &module) } Within the ApacheMain function, we attach the register_hooks callback to the module. And after that, register our Swift module as a regular Apache module. When Apache starts up, it runs its configuration process (actually twice, checkout the module devguide for more info). A part of that is registering the module hooks, in our example: register_hooks fileprivate func register_hooks(pool: OpaquePointer?) { // hookup the handlers you want ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE) } There are hooks which allow you to add callbacks to pretty much any part of Apache (configuration, process handling, path translation, authorization, etc.). In our simple case we just register a so called 'handler'. Handlers are pretty similar to what one may know as Middleware from other frameworks. And just like Middleware, they can decline to handle a request (return DECLINED), or process it (return OK or an error code). Lets look at our handler: mods_helloworldHandler Again, you can use any name. This is just a generated one. Also, you can have as many handlers as you want! func mods_helloworldHandler(p: UnsafeMutablePointer<request_rec>?) -> Int32 { var req = ApacheRequest(raw: p!) req.contentType = \"text/html; charset=ascii\" ... req.puts(\"<h3>Welcome to mods_helloworld</h3>\") ... return OK } The argument this function receives is the raw Apache C structure representing the current HTTP request. First thing we do is wrap it in a ApacheRequest Swift object, to make the API nicer (you can still call all Apache C API on the raw pointer!). Next we assign a content-type to the response (Apache uses a single object to represent both, Request and Response) and write out some content using req.puts . Then we return OK to tell Apache that our handler processed the request and no other content handler needs to run. Build Module Now that we looked at the source, lets build the module: swift apache build first invokes swift build and subsequently converts the build results into an Apache module shared library ( mods_helloworld.so ). $ swift apache build Fetching https://github.com/modswift/Apache.git Fetching https://github.com/modswift/CApache.git Completed resolution in 3.65s Cloning https://github.com/modswift/CApache.git Resolving https://github.com/modswift/CApache.git at 2.0.1 Cloning https://github.com/modswift/Apache.git Resolving https://github.com/modswift/Apache.git at 0.5.0 [2/2] Compiling Swift Module 'mods_helloworld' (1 sources) $ ls -hl .build/mods_helloworld.so -rwxr-xr-x 1 helge staff 173K 12 Mai 15:29 .build/mods_helloworld.so Run Module The swift apache serve command will generate an Apache configuration and start Apache with it. You can then access your module in the browser using either HTTP: http://localhost:8042/helloworld HTTPS / HTTP/2: https://localhost:8442/helloworld $ swift apache serve Note: DocRoot /usr/local/var/www/htdocs Starting Apache on port 8042/8442: GET /helloworld/ 200 715 - 0ms Note of interest: 0ms , the duration of the request. Yes, it is that fast ;-) In case you wonder, the generated Apache configuration can be found in .build/debug/apache.conf .","title":"Using mod_swift"},{"location":"usage/#hello-world","text":"Note: mod_swift only provides a very low level raw API. If you want something more convenient, checkout ApacheExpress . But lets do a simple mods_helloworld module for demonstration purposes.","title":"Hello World"},{"location":"usage/#setup-module","text":"Setup a new directory and initialize it as an Apache Swift module: $ mkdir mods_helloworld && cd mods_helloworld $ swift apache init The Swift Apache build environment looks sound. module: mods_helloworld config: debug product: /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so apxs: /usr/local/bin/apxs mod_swift: /usr/local/opt/mod_swift This creates a Swift Package Manager module and places an example Apache entry point into it: $ tree . \u251c\u2500\u2500 Package.swift \u2514\u2500\u2500 Sources \u2514\u2500\u2500 mods_helloworld \u2514\u2500\u2500 mods_helloworld.swift 2 directory, 2 files The Package.swift just loads the Apache wrapper module we provide: import PackageDescription let package = Package( name: \"mods_helloworld\", dependencies: [ .package(url: \"https://github.com/modswift/Apache.git\", from: \"0.5.0\") ], targets: [ .target(name: \"mods_helloworld\", dependencies: [ \"Apache\" ]) ] ) The mods_helloworld.swift source file contains a demo Apache module. The file can be named anything (but main.swift, which would produce a tool instead of a library ;-) import CApache import Apache var module = CApache.module(name: \"mods_helloworld\") func mods_helloworldHandler(p: UnsafeMutablePointer<request_rec>?) -> Int32 { // example content handler, modify to your liking var req = ApacheRequest(raw: p!) req.contentType = \"text/html; charset=ascii\" req.puts(\"<html><head><title>Hello mod_swift</title>\\(semanticUI)</head>\") req.puts(\"<body><div class='ui main container' style='margin-top: 1em;'>\") req.puts(\"<h3>Welcome to mods_helloworld</h3>\") defer { req.puts(\"</div></body></html>\") } req.puts(\"<h4>Links of Interest</h4>\") req.puts(\"<ul>\") req.puts(\" <li><a href='http://mod-swift.org/'>mod-swift.org</a></li>\") req.puts(\" <li><a href='http://apacheexpress.io/'>ApacheExpress</a></li>\") req.puts(\" <li><a href='https://httpd.apache.org/'>Apache</a></li>\") req.puts(\"</ul>\") return OK } fileprivate func register_hooks(pool: OpaquePointer?) { // hookup the handlers you want ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE) } @_cdecl(\"ApacheMain\") public func ApacheMain(cmd: UnsafeMutablePointer<cmd_parms>) { module.register_hooks = register_hooks let rc = apz_register_swift_module(cmd, &module) assert(rc == APR_SUCCESS, \"Could not add Swift module!\") }","title":"Setup Module"},{"location":"usage/#explanation-of-the-source","text":"","title":"Explanation of the Source"},{"location":"usage/#module-structure","text":"At the top this prepares the Apache module structure. The structure identifies our module within Apache. It contains the name, links to our callbacks, and optionally configuration data (yes, you can also add your own configuration directives to the Apache config). var module = CApache.module(name: \"mods_helloworld\") Which is registered at the bottom, in the ApacheMain function:","title":"Module Structure"},{"location":"usage/#apachemain","text":"ApacheMain is the primary entry point which is called by mod_swift when it executes the LoadSwiftModule directive in the Apache configuration. The @_cdecl isn't actually required in this case, but can be necessary in more complex setups. It tells Apache where to find the entry function (Apache being written in C, needs to have a C name, which often, but not always can be derived - the cdecl makes it explicit). @_cdecl(\"ApacheMain\") public func ApacheMain(cmd: UnsafeMutablePointer<cmd_parms>) { module.register_hooks = register_hooks let rc = apz_register_swift_module(cmd, &module) } Within the ApacheMain function, we attach the register_hooks callback to the module. And after that, register our Swift module as a regular Apache module. When Apache starts up, it runs its configuration process (actually twice, checkout the module devguide for more info). A part of that is registering the module hooks, in our example:","title":"ApacheMain()"},{"location":"usage/#register_hooks","text":"fileprivate func register_hooks(pool: OpaquePointer?) { // hookup the handlers you want ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE) } There are hooks which allow you to add callbacks to pretty much any part of Apache (configuration, process handling, path translation, authorization, etc.). In our simple case we just register a so called 'handler'. Handlers are pretty similar to what one may know as Middleware from other frameworks. And just like Middleware, they can decline to handle a request (return DECLINED), or process it (return OK or an error code). Lets look at our handler:","title":"register_hooks"},{"location":"usage/#mods_helloworldhandler","text":"Again, you can use any name. This is just a generated one. Also, you can have as many handlers as you want! func mods_helloworldHandler(p: UnsafeMutablePointer<request_rec>?) -> Int32 { var req = ApacheRequest(raw: p!) req.contentType = \"text/html; charset=ascii\" ... req.puts(\"<h3>Welcome to mods_helloworld</h3>\") ... return OK } The argument this function receives is the raw Apache C structure representing the current HTTP request. First thing we do is wrap it in a ApacheRequest Swift object, to make the API nicer (you can still call all Apache C API on the raw pointer!). Next we assign a content-type to the response (Apache uses a single object to represent both, Request and Response) and write out some content using req.puts . Then we return OK to tell Apache that our handler processed the request and no other content handler needs to run.","title":"mods_helloworldHandler"},{"location":"usage/#build-module","text":"Now that we looked at the source, lets build the module: swift apache build first invokes swift build and subsequently converts the build results into an Apache module shared library ( mods_helloworld.so ). $ swift apache build Fetching https://github.com/modswift/Apache.git Fetching https://github.com/modswift/CApache.git Completed resolution in 3.65s Cloning https://github.com/modswift/CApache.git Resolving https://github.com/modswift/CApache.git at 2.0.1 Cloning https://github.com/modswift/Apache.git Resolving https://github.com/modswift/Apache.git at 0.5.0 [2/2] Compiling Swift Module 'mods_helloworld' (1 sources) $ ls -hl .build/mods_helloworld.so -rwxr-xr-x 1 helge staff 173K 12 Mai 15:29 .build/mods_helloworld.so","title":"Build Module"},{"location":"usage/#run-module","text":"The swift apache serve command will generate an Apache configuration and start Apache with it. You can then access your module in the browser using either HTTP: http://localhost:8042/helloworld HTTPS / HTTP/2: https://localhost:8442/helloworld $ swift apache serve Note: DocRoot /usr/local/var/www/htdocs Starting Apache on port 8042/8442: GET /helloworld/ 200 715 - 0ms Note of interest: 0ms , the duration of the request. Yes, it is that fast ;-) In case you wonder, the generated Apache configuration can be found in .build/debug/apache.conf .","title":"Run Module"}]}