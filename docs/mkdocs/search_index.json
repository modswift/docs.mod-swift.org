{
    "docs": [
        {
            "location": "/", 
            "text": "mod_swift Documentation\n\n\nmod_swift\n allows you to write native modules\nfor the\n\nApache Web Server\n\nin the \n\nSwift 3\n\nprogramming language.\nThat is without any proxies, interpreters or other hacks - fully integrated,\ncompiled Apache modules that can do anything a C module could do.\n\n\nServer Side Swift the right way.\n\n\nWhat is an Apache module?\n\n\nApache is a highly modular and efficient server framework. The httpd\ndaemon itself is quite tiny and pretty much all webserver functionality is\nactually implemented in the form of\n\nmodules\n.\nBe it thread handling, access control, mime detection or content negotation -\nall of that is implemented as modules. And can be replaced by own modules!\n\n\nThe Apache core modules are written in portable C. Some modules are built\nright into the server, but most are loaded as\n\ndynamic libraries\n.\nWhich ones is specified by the user in the\n\nconfiguration file\n,\nfor example:\n\n\nLoadModule authz_core_module /usr/libexec/apache2/mod_authz_core.so\nLoadModule mime_module       /usr/libexec/apache2/mod_mime.so\n\n\n\nNow with \nmod_swift\n you can write such modules using the\n\nSwift\n\nprogramming language. Enter:\n\n\nLoadSwiftModule ApacheMain /usr/libexec/apache2/mods_demo.so\n\n\n\nThis is a little different to something like \nmod_php\n which enables Apache\nto directly interpret PHP scripts. \nmod_php\n itself is C software and a single\nmodule.\nSince Swift compiles down to regular executable binaries,\nand because Swift has excellent \n\nC integration\n,\nyou can write arbitrary modules with \nmod_swift\n which behave just like the\nregular C modules.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#mod_swift-documentation", 
            "text": "mod_swift  allows you to write native modules\nfor the Apache Web Server \nin the  Swift 3 \nprogramming language.\nThat is without any proxies, interpreters or other hacks - fully integrated,\ncompiled Apache modules that can do anything a C module could do.  Server Side Swift the right way.", 
            "title": "mod_swift Documentation"
        }, 
        {
            "location": "/#what-is-an-apache-module", 
            "text": "Apache is a highly modular and efficient server framework. The httpd\ndaemon itself is quite tiny and pretty much all webserver functionality is\nactually implemented in the form of modules .\nBe it thread handling, access control, mime detection or content negotation -\nall of that is implemented as modules. And can be replaced by own modules!  The Apache core modules are written in portable C. Some modules are built\nright into the server, but most are loaded as dynamic libraries .\nWhich ones is specified by the user in the configuration file ,\nfor example:  LoadModule authz_core_module /usr/libexec/apache2/mod_authz_core.so\nLoadModule mime_module       /usr/libexec/apache2/mod_mime.so  Now with  mod_swift  you can write such modules using the Swift \nprogramming language. Enter:  LoadSwiftModule ApacheMain /usr/libexec/apache2/mods_demo.so  This is a little different to something like  mod_php  which enables Apache\nto directly interpret PHP scripts.  mod_php  itself is C software and a single\nmodule.\nSince Swift compiles down to regular executable binaries,\nand because Swift has excellent  C integration ,\nyou can write arbitrary modules with  mod_swift  which behave just like the\nregular C modules.", 
            "title": "What is an Apache module?"
        }, 
        {
            "location": "/install/", 
            "text": "mod_swift Installation\n\n\nmod_swift should install fine on pretty much any Unix system that can run\nSwift and Apache 2.4. Including exotic setups like Raspberry Pi systems.\n\n\nWe also provide a macOS Homebrew tap which makes it really easy to install\nmod_swift and its dependencies on macOS. We highly recommend that over a\ncustom install.\n\n\nOn the Linux side we test w/ Ubuntu Trusty and Xenial, though it should work\npretty much anywhere.\n\n\nInstall on macOS using Homebrew\n\n\nGot no Homebrew? \nGet it!\n\n\nBefore you install mod_swift, we highly recommend that you install or reinstall\nthe Homebrew Apache w/ HTTP/2 and the MPM event module:\n\n\nbrew tap homebrew/apache\nbrew reinstall httpd24 --with-mpm-event --with-http2\n\n\n\nYou can also add \n--with-privileged-ports\n if you want to use such.\n\n\nThen add the mod_swift tap and install mod_swift:\n\n\nbrew tap modswift/mod_swift\nbrew install mod_swift\n\n\n\n(yes, the account is just modswift w/o underscore due to GitHub limitations)\n\n\nInstall on Linux (or macOS w/o Homebrew)\n\n\nOn macOS: We strongly advise that you rather use Homebrew, more importantly\n          the Apache provided by Homebrew.\n\n\nUbuntu packages required (assuming you have Swift 3 installed already):\n\n\nsudo apt-get install \\\n   pkg-config libapr1-dev libaprutil1-dev \\\n   libxml2 apache2 apache2-dev \\\n   libnghttp2-dev \\\n   libaprutil1-dbd-sqlite3 \\\n   libaprutil1-dbd-pgsql\n\n\n\nInstall:\n\n\nsudo make install\n\n\n\nThat puts mod_swift into \n/usr/local\n. If you want to have it in \n/usr\n, do:\n\n\nsudo make prefix=/usr install\n\n\n\nCheck whether the installation is OK\n\n\nYou can call \nswift apache validate\n to make sure the installation is OK:\n\n\n$ swift apache validate\nThe Swift Apache build environment looks sound.\n\nsrcroot:   /Users/helge/dev/Swift/Apex3\nmodule:    mods_Apex3\nconfig:    debug\nproduct:   /Users/helge/dev/Swift/Apex3/.build/mods_Apex3.so\napxs:      /usr/local/bin/apxs\nmod_swift: /usr/local\nswift:     3.1.0\ncert:      self-signed-mod_swift-localhost-server.crt\nhttp/2:    yes\n\n\n\nTroubleshooting\n\n\nIf something isn't working in a Homebrew setup, check whether:\n\n\nbrew doctor\n\n\n\noutputs anything unusual.\n\n\nIf you need any help, feel free to ask on the\n\nMailing List\n\nor our\n\nSlack channel\n.", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#mod_swift-installation", 
            "text": "mod_swift should install fine on pretty much any Unix system that can run\nSwift and Apache 2.4. Including exotic setups like Raspberry Pi systems.  We also provide a macOS Homebrew tap which makes it really easy to install\nmod_swift and its dependencies on macOS. We highly recommend that over a\ncustom install.  On the Linux side we test w/ Ubuntu Trusty and Xenial, though it should work\npretty much anywhere.", 
            "title": "mod_swift Installation"
        }, 
        {
            "location": "/install/#install-on-macos-using-homebrew", 
            "text": "Got no Homebrew?  Get it!  Before you install mod_swift, we highly recommend that you install or reinstall\nthe Homebrew Apache w/ HTTP/2 and the MPM event module:  brew tap homebrew/apache\nbrew reinstall httpd24 --with-mpm-event --with-http2  You can also add  --with-privileged-ports  if you want to use such.  Then add the mod_swift tap and install mod_swift:  brew tap modswift/mod_swift\nbrew install mod_swift  (yes, the account is just modswift w/o underscore due to GitHub limitations)", 
            "title": "Install on macOS using Homebrew"
        }, 
        {
            "location": "/install/#install-on-linux-or-macos-wo-homebrew", 
            "text": "On macOS: We strongly advise that you rather use Homebrew, more importantly\n          the Apache provided by Homebrew.  Ubuntu packages required (assuming you have Swift 3 installed already):  sudo apt-get install \\\n   pkg-config libapr1-dev libaprutil1-dev \\\n   libxml2 apache2 apache2-dev \\\n   libnghttp2-dev \\\n   libaprutil1-dbd-sqlite3 \\\n   libaprutil1-dbd-pgsql  Install:  sudo make install  That puts mod_swift into  /usr/local . If you want to have it in  /usr , do:  sudo make prefix=/usr install", 
            "title": "Install on Linux (or macOS w/o Homebrew)"
        }, 
        {
            "location": "/install/#check-whether-the-installation-is-ok", 
            "text": "You can call  swift apache validate  to make sure the installation is OK:  $ swift apache validate\nThe Swift Apache build environment looks sound.\n\nsrcroot:   /Users/helge/dev/Swift/Apex3\nmodule:    mods_Apex3\nconfig:    debug\nproduct:   /Users/helge/dev/Swift/Apex3/.build/mods_Apex3.so\napxs:      /usr/local/bin/apxs\nmod_swift: /usr/local\nswift:     3.1.0\ncert:      self-signed-mod_swift-localhost-server.crt\nhttp/2:    yes", 
            "title": "Check whether the installation is OK"
        }, 
        {
            "location": "/install/#troubleshooting", 
            "text": "If something isn't working in a Homebrew setup, check whether:  brew doctor  outputs anything unusual.  If you need any help, feel free to ask on the Mailing List \nor our Slack channel .", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/usage/", 
            "text": "Hello World\n\n\nNote: mod_swift only provides a very low level raw API. If you want something\nmore convenient, checkout \nApacheExpress\n.\n\n\nBut lets do a simple \nmods_helloworld\n module for demonstration purposes.\n\n\nSetup Module\n\n\nSetup a new directory and initialize it as an Apache Swift module:\n\n\n$ mkdir mods_helloworld \n cd mods_helloworld\n$ swift apache init\nThe Swift Apache build environment looks sound.\n\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift\n\n\n\n\nThis creates a Swift Package Manager module and places an example Apache entry\npoint into it:\n\n\n$ tree\n.\n\u251c\u2500\u2500 Package.swift\n\u2514\u2500\u2500 Sources\n    \u2514\u2500\u2500 mods_helloworld.swift\n\n1 directory, 2 files\n\n\n\n\nThe \nPackage.swift\n just loads the Apache wrapper module we provide:\n\n\nimport PackageDescription\n\nlet package = Package(\n    name: \nmods_helloworld\n,\n\n    dependencies: [\n      .Package(url: \nhttps://github.com/modswift/Apache.git\n, \n               majorVersion: 0)\n    ]\n)\n\n\n\n\nThe \nmods_helloworld.swift\n source file contains a demo Apache module. The\nfile can be named anything (but main.swift, which would produce a tool instead\nof a library ;-)\n\n\nimport CApache\nimport Apache\n\nvar module = CApache.module(name: \nmods_helloworld\n)\n\nfunc mods_helloworldHandler(p: UnsafeMutablePointer\nrequest_rec\n?) -\n Int32 {\n  // example content handler, modify to your liking\n  var req = ApacheRequest(raw: p!)\n\n  req.contentType = \ntext/html; charset=ascii\n\n  req.puts(\nhtml\nhead\ntitle\nHello mod_swift\n/title\n\\(semanticUI)\n/head\n)\n  req.puts(\nbody\ndiv class='ui main container' style='margin-top: 1em;'\n)\n  req.puts(\nh3\nWelcome to mods_helloworld\n/h3\n)\n  defer { req.puts(\n/div\n/body\n/html\n) }\n\n  req.puts(\nh4\nLinks of Interest\n/h4\n)\n  req.puts(\nul\n)\n  req.puts(\n  \nli\na href='http://mod-swift.org/'\nmod-swift.org\n/a\n/li\n)\n  req.puts(\n  \nli\na href='http://apacheexpress.io/'\nApacheExpress\n/a\n/li\n)\n  req.puts(\n  \nli\na href='https://httpd.apache.org/'\nApache\n/a\n/li\n)\n\n  req.puts(\n/ul\n)\n  return OK\n}\n\nfileprivate func register_hooks(pool: OpaquePointer?) {\n  // hookup the handlers you want\n  ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE)\n}\n\n@_cdecl(\nApacheMain\n)\npublic func ApacheMain(cmd: UnsafeMutablePointer\ncmd_parms\n) {\n  module.register_hooks = register_hooks\n\n  let rc = apz_register_swift_module(cmd, \nmodule)\n  assert(rc == APR_SUCCESS, \nCould not add Swift module!\n)\n}\n\n\n\n\nExplanation of the Source\n\n\nModule Structure\n\n\nAt the top this prepares the Apache module structure. The structure identifies\nour module within Apache. It contains the name, links to our callbacks, and\noptionally configuration data (yes, you can also add your own configuration\ndirectives to the Apache config).\n\n\nvar module = CApache.module(name: \nmods_helloworld\n)\n\n\n\n\nWhich is registered at the bottom, in the \nApacheMain\n function:\n\n\nApacheMain()\n\n\nApacheMain\n is the primary entry point which is called by mod_swift when it\nexecutes the \nLoadSwiftModule\n directive in the Apache configuration.\nThe \n@_cdecl\n isn't actually required in this case, but can be necessary in more\ncomplex setups. It tells Apache where to find the entry\nfunction (Apache being written in C, needs to have a C name, which often, but\nnot always can be derived - the cdecl makes it explicit).\n\n\n@_cdecl(\nApacheMain\n)\npublic func ApacheMain(cmd: UnsafeMutablePointer\ncmd_parms\n) {\n  module.register_hooks = register_hooks\n\n  let rc = apz_register_swift_module(cmd, \nmodule)\n}\n\n\n\n\nWithin the ApacheMain function, we attach the \nregister_hooks\n callback to\nthe module. And after that, register our Swift module as a regular Apache\nmodule.\nWhen Apache starts up, it runs its configuration process (actually twice,\ncheckout the module devguide for more info).\nA part of that is registering the module hooks, in our example:\n\n\nregister_hooks\n\n\nfileprivate func register_hooks(pool: OpaquePointer?) {\n  // hookup the handlers you want\n  ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE)\n}\n\n\n\n\nThere are hooks which allow you to add callbacks to pretty much any part of\nApache (configuration, process handling, path translation, authorization, etc.).\nIn our simple case we just register a so called 'handler'.\nHandlers are pretty similar to what one may know as Middleware from other\nframeworks. And just like Middleware, they can decline to handle a request\n(return DECLINED), or process it (return OK or an error code).\nLets look at our handler:\n\n\nmods_helloworldHandler\n\n\nAgain, you can use any name. This is just a generated one. Also, you can have as\nmany handlers as you want!\n\n\nfunc mods_helloworldHandler(p: UnsafeMutablePointer\nrequest_rec\n?) -\n Int32 {\n  var req = ApacheRequest(raw: p!)\n  req.contentType = \ntext/html; charset=ascii\n\n...\n  req.puts(\nh3\nWelcome to mods_helloworld\n/h3\n)\n...  \n  return OK\n}\n\n\n\n\nThe argument this function receives is the raw Apache C structure representing\nthe current HTTP request. First thing we do is wrap it in a \nApacheRequest\n\nSwift object, to make the API nicer (you can still call all Apache C API on the\nraw pointer!).\n\n\nNext we assign a content-type to the response (Apache uses a single object\nto represent both, Request and Response) and write out some content using\n\nreq.puts\n.\n\n\nThen we return \nOK\n to tell Apache that our handler processed the request and\nno other content handler needs to run.\n\n\nBuild Module\n\n\nNow that we looked at the source, lets build the module:\n\nswift apache build\n first invokes \nswift build\n and subsequently converts the\nbuild results into an Apache module shared library (\nmods_helloworld.so\n).\n\n\n$ swift apache build\nCloning https://github.com/modswift/Apache.git\nHEAD is now at 37f3038 Travis: use `swift build`\nResolved version: 0.2.0\nCloning https://github.com/modswift/CApache.git\nHEAD is now at aa7d5b5 Tabs to spaces\nResolved version: 1.0.0\nCompile Swift Module 'Apache' (8 sources)\nCompile Swift Module 'mods_helloworld' (1 sources)\n\n$ ls -hl .build/mods_helloworld.so\n-rwxr-xr-x  1 helge  staff   240K May 30 16:05 .build/mods_helloworld.so\n\n\n\n\nRun Module\n\n\nThe \nswift apache serve\n command will generate an Apache configuration and\nstart Apache with it.\nYou can then access your module in the browser using either\n\n\n\n\nHTTP: \nhttp://localhost:8042/\n\n\nHTTPS / HTTP/2: \nhttps://localhost:8442/\n\n\n\n\n$ swift apache serve\nNote: DocRoot /usr/local/var/www/htdocs\nStarting Apache on port 8042/8442:\nGET /helloworld/ 200 715 - 0ms\n\n\n\n\nNote of interest: \n0ms\n, the duration of the request. Yes, it is \nthat\n fast ;-)\n\n\nIn case you wonder, the generated Apache configuration can be found in \n\n.build/debug/apache.conf\n.", 
            "title": "Using mod_swift"
        }, 
        {
            "location": "/usage/#hello-world", 
            "text": "Note: mod_swift only provides a very low level raw API. If you want something\nmore convenient, checkout  ApacheExpress .  But lets do a simple  mods_helloworld  module for demonstration purposes.", 
            "title": "Hello World"
        }, 
        {
            "location": "/usage/#setup-module", 
            "text": "Setup a new directory and initialize it as an Apache Swift module:  $ mkdir mods_helloworld   cd mods_helloworld\n$ swift apache init\nThe Swift Apache build environment looks sound.\n\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift  This creates a Swift Package Manager module and places an example Apache entry\npoint into it:  $ tree\n.\n\u251c\u2500\u2500 Package.swift\n\u2514\u2500\u2500 Sources\n    \u2514\u2500\u2500 mods_helloworld.swift\n\n1 directory, 2 files  The  Package.swift  just loads the Apache wrapper module we provide:  import PackageDescription\n\nlet package = Package(\n    name:  mods_helloworld ,\n\n    dependencies: [\n      .Package(url:  https://github.com/modswift/Apache.git , \n               majorVersion: 0)\n    ]\n)  The  mods_helloworld.swift  source file contains a demo Apache module. The\nfile can be named anything (but main.swift, which would produce a tool instead\nof a library ;-)  import CApache\nimport Apache\n\nvar module = CApache.module(name:  mods_helloworld )\n\nfunc mods_helloworldHandler(p: UnsafeMutablePointer request_rec ?) -  Int32 {\n  // example content handler, modify to your liking\n  var req = ApacheRequest(raw: p!)\n\n  req.contentType =  text/html; charset=ascii \n  req.puts( html head title Hello mod_swift /title \\(semanticUI) /head )\n  req.puts( body div class='ui main container' style='margin-top: 1em;' )\n  req.puts( h3 Welcome to mods_helloworld /h3 )\n  defer { req.puts( /div /body /html ) }\n\n  req.puts( h4 Links of Interest /h4 )\n  req.puts( ul )\n  req.puts(    li a href='http://mod-swift.org/' mod-swift.org /a /li )\n  req.puts(    li a href='http://apacheexpress.io/' ApacheExpress /a /li )\n  req.puts(    li a href='https://httpd.apache.org/' Apache /a /li )\n\n  req.puts( /ul )\n  return OK\n}\n\nfileprivate func register_hooks(pool: OpaquePointer?) {\n  // hookup the handlers you want\n  ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE)\n}\n\n@_cdecl( ApacheMain )\npublic func ApacheMain(cmd: UnsafeMutablePointer cmd_parms ) {\n  module.register_hooks = register_hooks\n\n  let rc = apz_register_swift_module(cmd,  module)\n  assert(rc == APR_SUCCESS,  Could not add Swift module! )\n}", 
            "title": "Setup Module"
        }, 
        {
            "location": "/usage/#explanation-of-the-source", 
            "text": "", 
            "title": "Explanation of the Source"
        }, 
        {
            "location": "/usage/#module-structure", 
            "text": "At the top this prepares the Apache module structure. The structure identifies\nour module within Apache. It contains the name, links to our callbacks, and\noptionally configuration data (yes, you can also add your own configuration\ndirectives to the Apache config).  var module = CApache.module(name:  mods_helloworld )  Which is registered at the bottom, in the  ApacheMain  function:", 
            "title": "Module Structure"
        }, 
        {
            "location": "/usage/#apachemain", 
            "text": "ApacheMain  is the primary entry point which is called by mod_swift when it\nexecutes the  LoadSwiftModule  directive in the Apache configuration.\nThe  @_cdecl  isn't actually required in this case, but can be necessary in more\ncomplex setups. It tells Apache where to find the entry\nfunction (Apache being written in C, needs to have a C name, which often, but\nnot always can be derived - the cdecl makes it explicit).  @_cdecl( ApacheMain )\npublic func ApacheMain(cmd: UnsafeMutablePointer cmd_parms ) {\n  module.register_hooks = register_hooks\n\n  let rc = apz_register_swift_module(cmd,  module)\n}  Within the ApacheMain function, we attach the  register_hooks  callback to\nthe module. And after that, register our Swift module as a regular Apache\nmodule.\nWhen Apache starts up, it runs its configuration process (actually twice,\ncheckout the module devguide for more info).\nA part of that is registering the module hooks, in our example:", 
            "title": "ApacheMain()"
        }, 
        {
            "location": "/usage/#register_hooks", 
            "text": "fileprivate func register_hooks(pool: OpaquePointer?) {\n  // hookup the handlers you want\n  ap_hook_handler(mods_helloworldHandler, nil, nil, APR_HOOK_MIDDLE)\n}  There are hooks which allow you to add callbacks to pretty much any part of\nApache (configuration, process handling, path translation, authorization, etc.).\nIn our simple case we just register a so called 'handler'.\nHandlers are pretty similar to what one may know as Middleware from other\nframeworks. And just like Middleware, they can decline to handle a request\n(return DECLINED), or process it (return OK or an error code).\nLets look at our handler:", 
            "title": "register_hooks"
        }, 
        {
            "location": "/usage/#mods_helloworldhandler", 
            "text": "Again, you can use any name. This is just a generated one. Also, you can have as\nmany handlers as you want!  func mods_helloworldHandler(p: UnsafeMutablePointer request_rec ?) -  Int32 {\n  var req = ApacheRequest(raw: p!)\n  req.contentType =  text/html; charset=ascii \n...\n  req.puts( h3 Welcome to mods_helloworld /h3 )\n...  \n  return OK\n}  The argument this function receives is the raw Apache C structure representing\nthe current HTTP request. First thing we do is wrap it in a  ApacheRequest \nSwift object, to make the API nicer (you can still call all Apache C API on the\nraw pointer!).  Next we assign a content-type to the response (Apache uses a single object\nto represent both, Request and Response) and write out some content using req.puts .  Then we return  OK  to tell Apache that our handler processed the request and\nno other content handler needs to run.", 
            "title": "mods_helloworldHandler"
        }, 
        {
            "location": "/usage/#build-module", 
            "text": "Now that we looked at the source, lets build the module: swift apache build  first invokes  swift build  and subsequently converts the\nbuild results into an Apache module shared library ( mods_helloworld.so ).  $ swift apache build\nCloning https://github.com/modswift/Apache.git\nHEAD is now at 37f3038 Travis: use `swift build`\nResolved version: 0.2.0\nCloning https://github.com/modswift/CApache.git\nHEAD is now at aa7d5b5 Tabs to spaces\nResolved version: 1.0.0\nCompile Swift Module 'Apache' (8 sources)\nCompile Swift Module 'mods_helloworld' (1 sources)\n\n$ ls -hl .build/mods_helloworld.so\n-rwxr-xr-x  1 helge  staff   240K May 30 16:05 .build/mods_helloworld.so", 
            "title": "Build Module"
        }, 
        {
            "location": "/usage/#run-module", 
            "text": "The  swift apache serve  command will generate an Apache configuration and\nstart Apache with it.\nYou can then access your module in the browser using either   HTTP:  http://localhost:8042/  HTTPS / HTTP/2:  https://localhost:8442/   $ swift apache serve\nNote: DocRoot /usr/local/var/www/htdocs\nStarting Apache on port 8042/8442:\nGET /helloworld/ 200 715 - 0ms  Note of interest:  0ms , the duration of the request. Yes, it is  that  fast ;-)  In case you wonder, the generated Apache configuration can be found in  .build/debug/apache.conf .", 
            "title": "Run Module"
        }, 
        {
            "location": "/configtemplates/", 
            "text": "Apache Configuration Templates\n\n\nmod_swift \ndoes not require\n any configuration. Within your Apache module,\nyou can just run\n\n\nswift apache serve\n\n\n\nand it'll derive a configuration from the module setup (i.e. issue proper\nLoadModule directives, configure a document root, HTTP/2 and so on).\n\n\nHowever, if you desire, you can tweak that process using mod_swift\nconfiguration templates.\n\n\nConfiguration Templates\n\n\nSystem Templates\n\n\nThe global Apache configuration is derived from the templates installed in\n\n{install-prefix}/lib/mod_swift/apache-config-templates/\n.\nIt contains debug/release versions as well as versions for macOS Homebrew\nand Ubuntu.\n\n\nFull Override: \napache.conf\n\n\nIf you don't want \nany\n auto-configuration by \nswift apache serve\n,\nyou can place a file called \napache.conf\n into your module directory.\nIf that exists, no configuration templating will happen, it is all\nup to you.\n\n\nCustom Templates\n\n\nIf the module directory contains a \napache-template.conf\n, that is going to\nbe used instead of the System Templates mentioned above.\n\n\nEither that or a system template is used as the basis. If it doesn't contain\na \nLoadModule swift_module\n, that will get attached next.\n\n\nIn the next step the configuration will check for \n{modulename}.conf\n\nand \n{modulename}-template.conf\n within your Swift Apache module directory.\nFor example \nmods_helloworld-template.conf\n.\n\n\nOne of the two is a good place to do additional configuration.\n\n\nExample Template\n\n\nA config template is a great way to configure \n\nApache mod_dbd\n\nfor the module.\n\n\nIf the module is called \nmods_testdb\n, create a new file called \n\nmods_testdb-template.conf\n with the necessary database configuration.\nFor example to configure Apache to access a SQLite3 database living within the\n\ndata\n directory of your module source:\n\n\nLoadModule dbd_module %APACHE_MODULE_DIR%/mod_dbd.so\n\n\nIfModule dbd_module\n\n  DBDriver  sqlite3\n  DBDParams \n%SRCROOT%/data/MyDatabase.sqlite3\n\n\n/IfModule\n\n\n\n\n\nNote how the \n%APACHE_MODULE_DIR%\n variable is used to refer to the module\nlocation.\nAlso note how \n%SRCROOT%\n is used to refer to the SQLite3 database file. This\nis necessary, because mod_dbd requires an \nabsolute\n path to the database file\n(i.e. a relative path like \n\"data/MyDatabase.sqlite3\"\n doesn't work).\n\n\nTemplate Variables\n\n\n\n\n%SRCROOT%\n\n\n%APACHE_PREFIX%\n\n\n%APACHE_PORT%\n\n\n%APACHE_SSL_PORT%\n\n\n%APACHE_PIDFILE%\n\n\n%APACHE_DOCROOT%\n\n\n%APACHE_MODULE_RELDIR%\n\n\n%APACHE_MODULE_DIR%\n\n\n%APACHE_SERVER_CERT_DIR%\n\n\n%APACHE_SERVER_CERT%\n\n\n%APACHE_SERVER_KEY%\n\n\n%APACHE_HTTP2_LOAD_COMMAND%\n\n\n%CONFIGURATION_BUILD_DIR%\n\n\n\n\nDocument Root Lookup\n\n\nmod_swift will look into the SRCROOT of the package and check for the\navailability of those directories:\n\n\n\n\nhtdocs/\n\n\nwww/\n\n\npublic/\n\n\n\n\nSo within modules, you can just create a \npublic\n directory, and Apache\nwill be configured to serve static files from there.\n\n\nIf none of those directories are available, it'll use whatever \n\napxs -q htdocsdir\n has as the document root.", 
            "title": "Configuration Templates"
        }, 
        {
            "location": "/configtemplates/#apache-configuration-templates", 
            "text": "mod_swift  does not require  any configuration. Within your Apache module,\nyou can just run  swift apache serve  and it'll derive a configuration from the module setup (i.e. issue proper\nLoadModule directives, configure a document root, HTTP/2 and so on).  However, if you desire, you can tweak that process using mod_swift\nconfiguration templates.", 
            "title": "Apache Configuration Templates"
        }, 
        {
            "location": "/configtemplates/#configuration-templates", 
            "text": "", 
            "title": "Configuration Templates"
        }, 
        {
            "location": "/configtemplates/#system-templates", 
            "text": "The global Apache configuration is derived from the templates installed in {install-prefix}/lib/mod_swift/apache-config-templates/ .\nIt contains debug/release versions as well as versions for macOS Homebrew\nand Ubuntu.", 
            "title": "System Templates"
        }, 
        {
            "location": "/configtemplates/#full-override-apacheconf", 
            "text": "If you don't want  any  auto-configuration by  swift apache serve ,\nyou can place a file called  apache.conf  into your module directory.\nIf that exists, no configuration templating will happen, it is all\nup to you.", 
            "title": "Full Override: apache.conf"
        }, 
        {
            "location": "/configtemplates/#custom-templates", 
            "text": "If the module directory contains a  apache-template.conf , that is going to\nbe used instead of the System Templates mentioned above.  Either that or a system template is used as the basis. If it doesn't contain\na  LoadModule swift_module , that will get attached next.  In the next step the configuration will check for  {modulename}.conf \nand  {modulename}-template.conf  within your Swift Apache module directory.\nFor example  mods_helloworld-template.conf .  One of the two is a good place to do additional configuration.", 
            "title": "Custom Templates"
        }, 
        {
            "location": "/configtemplates/#example-template", 
            "text": "A config template is a great way to configure  Apache mod_dbd \nfor the module.  If the module is called  mods_testdb , create a new file called  mods_testdb-template.conf  with the necessary database configuration.\nFor example to configure Apache to access a SQLite3 database living within the data  directory of your module source:  LoadModule dbd_module %APACHE_MODULE_DIR%/mod_dbd.so IfModule dbd_module \n  DBDriver  sqlite3\n  DBDParams  %SRCROOT%/data/MyDatabase.sqlite3  /IfModule   Note how the  %APACHE_MODULE_DIR%  variable is used to refer to the module\nlocation.\nAlso note how  %SRCROOT%  is used to refer to the SQLite3 database file. This\nis necessary, because mod_dbd requires an  absolute  path to the database file\n(i.e. a relative path like  \"data/MyDatabase.sqlite3\"  doesn't work).", 
            "title": "Example Template"
        }, 
        {
            "location": "/configtemplates/#template-variables", 
            "text": "%SRCROOT%  %APACHE_PREFIX%  %APACHE_PORT%  %APACHE_SSL_PORT%  %APACHE_PIDFILE%  %APACHE_DOCROOT%  %APACHE_MODULE_RELDIR%  %APACHE_MODULE_DIR%  %APACHE_SERVER_CERT_DIR%  %APACHE_SERVER_CERT%  %APACHE_SERVER_KEY%  %APACHE_HTTP2_LOAD_COMMAND%  %CONFIGURATION_BUILD_DIR%", 
            "title": "Template Variables"
        }, 
        {
            "location": "/configtemplates/#document-root-lookup", 
            "text": "mod_swift will look into the SRCROOT of the package and check for the\navailability of those directories:   htdocs/  www/  public/   So within modules, you can just create a  public  directory, and Apache\nwill be configured to serve static files from there.  If none of those directories are available, it'll use whatever  apxs -q htdocsdir  has as the document root.", 
            "title": "Document Root Lookup"
        }, 
        {
            "location": "/tools/", 
            "text": "mod_swift Tools\n\n\nmod_swift comes with a set of CLI tools that integrate with the \nSwift Package Manager.\nThe tools enhance the Swift Package Manager to be able to build native\nApache modules, configure them and run them.\nAll of them are invoked like:\n\n\nswift apache \nsubcommand\n\n\n\n\nIf the toolname is omitted, you get a small help:\n\n\n$ swift apache\nusage: swift apache \nsubcommand\n\n\nAvailable subcommands are:\n   init      Setup directory as a Swift Apache module Package.\n   build     Build Swift Package as a Swift module.\n   serve     Start Apache and load Swift Apache module.\n   validate  Check Apache build environment.\n\nTry 'swift apache \nsubcommand\n help' for details.\n\n\n\n\nNote\n: \nApacheExpress\n comes with its own set of\n        tools.\n\n\nswift apache init\n\n\nPrepare a directory as a Swift Apache module. This will setup a directory\nas a \nbarebones\n Swift Apache module\n(try \nApacheExpress\n for a higher level API!)\n\n\n$ mkdir mods_helloworld \n cd mods_helloworld\n$ swift apache init\nThe Swift Apache build environment looks sound.\n\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift\n\n\n\n\nswift apache build\n\n\nswift apache build\n first invokes \nswift build\n and subsequently converts the\nbuild results into an Apache module shared library.\n\n\n$ swift apache build\nCloning https://github.com/modswift/Apache.git\nHEAD is now at 37f3038 Travis: use `swift build`\nResolved version: 0.2.0\nCloning https://github.com/modswift/CApache.git\nHEAD is now at aa7d5b5 Tabs to spaces\nResolved version: 1.0.0\nCompile Swift Module 'Apache' (8 sources)\nCompile Swift Module 'mods_helloworld' (1 sources)\n\n$ ls -hl .build/mods_helloworld.so\n-rwxr-xr-x  1 helge  staff   240K May 30 16:05 .build/mods_helloworld.so\n\n\n\n\nswift apache serve\n\n\nThe \nswift apache serve\n command will generate an Apache configuration and\nstart Apache with it.\nYou can then access your module in the browser using either\n\n\n\n\nHTTP: \nhttp://localhost:8042/\n\n\nHTTPS / HTTP2/: \nhttps://localhost:8442/\n\n\n\n\n$ swift apache serve\nNote: DocRoot /usr/local/var/www/htdocs\nStarting Apache on port 8042/8442:\nGET /helloworld/ 200 715 - 0ms\n\n\n\n\nYou can modify the configuration which is created using\n\nmod_swift config templates\n.\n\n\nswift apache validate\n\n\nswift apache validate\n just checks whether a build is likely to be successful\nand prints out the configuration assumptions it has.\n\n\n$ swift apache validate\nThe Swift Apache build environment looks sound.\n\n  srcroot:   /Users/helge/tmp/tests/mods_helloworld\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift\n  swift:     3.0.2\n  cert:      self-signed-mod_swift-localhost-server.crt\n  http/2:    yes", 
            "title": "Tools Reference"
        }, 
        {
            "location": "/tools/#mod_swift-tools", 
            "text": "mod_swift comes with a set of CLI tools that integrate with the \nSwift Package Manager.\nThe tools enhance the Swift Package Manager to be able to build native\nApache modules, configure them and run them.\nAll of them are invoked like:  swift apache  subcommand   If the toolname is omitted, you get a small help:  $ swift apache\nusage: swift apache  subcommand \n\nAvailable subcommands are:\n   init      Setup directory as a Swift Apache module Package.\n   build     Build Swift Package as a Swift module.\n   serve     Start Apache and load Swift Apache module.\n   validate  Check Apache build environment.\n\nTry 'swift apache  subcommand  help' for details.  Note :  ApacheExpress  comes with its own set of\n        tools.", 
            "title": "mod_swift Tools"
        }, 
        {
            "location": "/tools/#swift-apache-init", 
            "text": "Prepare a directory as a Swift Apache module. This will setup a directory\nas a  barebones  Swift Apache module\n(try  ApacheExpress  for a higher level API!)  $ mkdir mods_helloworld   cd mods_helloworld\n$ swift apache init\nThe Swift Apache build environment looks sound.\n\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift", 
            "title": "swift apache init"
        }, 
        {
            "location": "/tools/#swift-apache-build", 
            "text": "swift apache build  first invokes  swift build  and subsequently converts the\nbuild results into an Apache module shared library.  $ swift apache build\nCloning https://github.com/modswift/Apache.git\nHEAD is now at 37f3038 Travis: use `swift build`\nResolved version: 0.2.0\nCloning https://github.com/modswift/CApache.git\nHEAD is now at aa7d5b5 Tabs to spaces\nResolved version: 1.0.0\nCompile Swift Module 'Apache' (8 sources)\nCompile Swift Module 'mods_helloworld' (1 sources)\n\n$ ls -hl .build/mods_helloworld.so\n-rwxr-xr-x  1 helge  staff   240K May 30 16:05 .build/mods_helloworld.so", 
            "title": "swift apache build"
        }, 
        {
            "location": "/tools/#swift-apache-serve", 
            "text": "The  swift apache serve  command will generate an Apache configuration and\nstart Apache with it.\nYou can then access your module in the browser using either   HTTP:  http://localhost:8042/  HTTPS / HTTP2/:  https://localhost:8442/   $ swift apache serve\nNote: DocRoot /usr/local/var/www/htdocs\nStarting Apache on port 8042/8442:\nGET /helloworld/ 200 715 - 0ms  You can modify the configuration which is created using mod_swift config templates .", 
            "title": "swift apache serve"
        }, 
        {
            "location": "/tools/#swift-apache-validate", 
            "text": "swift apache validate  just checks whether a build is likely to be successful\nand prints out the configuration assumptions it has.  $ swift apache validate\nThe Swift Apache build environment looks sound.\n\n  srcroot:   /Users/helge/tmp/tests/mods_helloworld\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift\n  swift:     3.0.2\n  cert:      self-signed-mod_swift-localhost-server.crt\n  http/2:    yes", 
            "title": "swift apache validate"
        }, 
        {
            "location": "/apacheexpress/", 
            "text": "ApacheExpress\n\n\nApacheExpress\n is a framework layering on top of \nmod_swift.\nIt makes it very easy to quickly build reliable and feature rich Swift server\napplications from within Xcode or using the Swift Package Manager.\nIt supports convenient database access using Apache mod_dbd.\nAnd well, can be used together with all the other regular Apache modules.\n\n\nExample:\n\n\npublic func ApacheMain(_ cmd: OpaquePointer) {\n  let app = ApacheExpress.express(cmd)\n\n  app.use(cookieParser())\n\n  app.get(\n/cookies.json\n) { req, res, next in\n    try res.json(req.cookies)\n  }\n\n  app.get(\n/\n) { req, res, next in\n    let values : [ String : Any ] = [\n      \ncowOfTheDay\n : cows.vaca()\n    ]\n    try res.render(\nindex\n, values)\n  }\n}\n\n\n\n\n\n\nApacheExpress Homepage\n\n\nApacheExpress Documentation", 
            "title": "ApacheExpress"
        }, 
        {
            "location": "/apacheexpress/#apacheexpress", 
            "text": "ApacheExpress  is a framework layering on top of \nmod_swift.\nIt makes it very easy to quickly build reliable and feature rich Swift server\napplications from within Xcode or using the Swift Package Manager.\nIt supports convenient database access using Apache mod_dbd.\nAnd well, can be used together with all the other regular Apache modules.  Example:  public func ApacheMain(_ cmd: OpaquePointer) {\n  let app = ApacheExpress.express(cmd)\n\n  app.use(cookieParser())\n\n  app.get( /cookies.json ) { req, res, next in\n    try res.json(req.cookies)\n  }\n\n  app.get( / ) { req, res, next in\n    let values : [ String : Any ] = [\n       cowOfTheDay  : cows.vaca()\n    ]\n    try res.render( index , values)\n  }\n}   ApacheExpress Homepage  ApacheExpress Documentation", 
            "title": "ApacheExpress"
        }, 
        {
            "location": "/http2/", 
            "text": "HTTP/2\n\n\nIf your server provides the \nmod_http2\n module, \nswift apache\n will\nautomatically pick it up, configure a development SSL certificate and\nthe HTTP/2 module.\nBy default the \n\n\nCheck whether HTTP/2 is available\n\n\nTo check whether mod_swift did detect the HTTP/2 module successfully, you can\nrun:\n\n\n$ swift apache validate\nThe Swift Apache build environment looks sound.\n\n  srcroot:   /Users/helge/tmp/tests/mods_helloworld\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift\n  swift:     3.0.2\n  cert:      self-signed-mod_swift-localhost-server.crt\n  http/2:    yes\n\n\n\n\nLook for the last line and check whether it says \nyes\n.\n\n\nInstall the Homebrew Apache w/ HTTP/2\n\n\nBefore you install mod_swift, we highly recommend that you install or reinstall\nthe Homebrew Apache w/ HTTP/2 and the MPM event module:\n\n\nbrew tap homebrew/apache\nbrew reinstall httpd24 --with-mpm-event --with-http2\n\n\n\nYou can also add \n--with-privileged-ports\n if you want to use such.\n\n\nUseful tools\n\n\nChrome Developer Tools\n\n\nYou can use the \nNetwork\n tab in the Chrome Developer Tools to check whether\nrequests are done using HTTP/2. Right click the table view and select\n'Protocol'.\n\n\ncurl w/ HTTP/2 support\n\n\nOn Homebrew you can easily install \ncurl\n with HTTP/2 support:\n\n\nbrew reinstall curl --with-nghttp2 --with-openssl\n\n\n\nIMPORTANT\n: curl is Cellar only w/ Homebrew. To invoke it either adjust your\n\nPATH\n to include \n/use/local/opt/curl/bin\n or invoke curl with the full path:\n\n\n/usr/local/opt/curl/bin/curl -v --insecure --http2 https://localhost:8442/hello\n\n\n\n\n(--insecure is needed if you use it w/ the self-signed certificate coming w/\n mod_swift)\n\n\nYou can scan the output of curl to see whether it is actually using HTTP/2:\n\n\n...\n* ALPN, offering h2\n* ALPN, offering http/1.1\n...\n* Using HTTP2, server supports multi-use\n* Connection state changed (HTTP/2 confirmed)\n...\n\n GET /hello HTTP/2\n...\n\n HTTP/2 200\n...\n\n\n\n\nLinks\n\n\n\n\nhow to h2 in apache", 
            "title": "HTTP/2"
        }, 
        {
            "location": "/http2/#http2", 
            "text": "If your server provides the  mod_http2  module,  swift apache  will\nautomatically pick it up, configure a development SSL certificate and\nthe HTTP/2 module.\nBy default the", 
            "title": "HTTP/2"
        }, 
        {
            "location": "/http2/#check-whether-http2-is-available", 
            "text": "To check whether mod_swift did detect the HTTP/2 module successfully, you can\nrun:  $ swift apache validate\nThe Swift Apache build environment looks sound.\n\n  srcroot:   /Users/helge/tmp/tests/mods_helloworld\n  module:    mods_helloworld\n  config:    debug\n  product:   /Users/helge/tmp/tests/mods_helloworld/.build/mods_helloworld.so\n  apxs:      /usr/local/bin/apxs\n  mod_swift: /usr/local/opt/mod_swift\n  swift:     3.0.2\n  cert:      self-signed-mod_swift-localhost-server.crt\n  http/2:    yes  Look for the last line and check whether it says  yes .", 
            "title": "Check whether HTTP/2 is available"
        }, 
        {
            "location": "/http2/#install-the-homebrew-apache-w-http2", 
            "text": "Before you install mod_swift, we highly recommend that you install or reinstall\nthe Homebrew Apache w/ HTTP/2 and the MPM event module:  brew tap homebrew/apache\nbrew reinstall httpd24 --with-mpm-event --with-http2  You can also add  --with-privileged-ports  if you want to use such.", 
            "title": "Install the Homebrew Apache w/ HTTP/2"
        }, 
        {
            "location": "/http2/#useful-tools", 
            "text": "", 
            "title": "Useful tools"
        }, 
        {
            "location": "/http2/#chrome-developer-tools", 
            "text": "You can use the  Network  tab in the Chrome Developer Tools to check whether\nrequests are done using HTTP/2. Right click the table view and select\n'Protocol'.", 
            "title": "Chrome Developer Tools"
        }, 
        {
            "location": "/http2/#curl-w-http2-support", 
            "text": "On Homebrew you can easily install  curl  with HTTP/2 support:  brew reinstall curl --with-nghttp2 --with-openssl  IMPORTANT : curl is Cellar only w/ Homebrew. To invoke it either adjust your PATH  to include  /use/local/opt/curl/bin  or invoke curl with the full path:  /usr/local/opt/curl/bin/curl -v --insecure --http2 https://localhost:8442/hello  (--insecure is needed if you use it w/ the self-signed certificate coming w/\n mod_swift)  You can scan the output of curl to see whether it is actually using HTTP/2:  ...\n* ALPN, offering h2\n* ALPN, offering http/1.1\n...\n* Using HTTP2, server supports multi-use\n* Connection state changed (HTTP/2 confirmed)\n...  GET /hello HTTP/2\n...  HTTP/2 200\n...", 
            "title": "curl w/ HTTP/2 support"
        }, 
        {
            "location": "/http2/#links", 
            "text": "how to h2 in apache", 
            "title": "Links"
        }, 
        {
            "location": "/mod_dbd/", 
            "text": "Database Access using mod_dbd\n\n\nA feature of Apache 2 known to few is\n\nmod_dbd\n.\nUsing that you can configure a SQL database connection within the \n\nApache.conf\n\nand use that within all your Apache modules/handlers.\n\n\nNote\n: Shown below is pretty raw access to mod_dbd as provided by the\n          mod_swift \nApache\n wrapper\n          module.\n          You can use \nApacheExpress\n to access\n          databases using the \nZeeQL\n library,\n          which is way more convenient.\n\n\nThis will setup a directory as a barebones Swift Apache module (try ApacheExpress for a higher level API!)\n\n\nThough you can also write your own, Apache 2 comes with drivers for \n\nSQLite3\n, \n\nPostgreSQL\n,\nMySQL and Oracle.\nThe macOS system Apache and the one than can be tapped in Homebrew\nincludes SQLite3.\nOn Linux you can easily install the ones you want:\n\n\nsudo apt-get install libaprutil1-dbd-sqlite3 libaprutil1-dbd-pgsql\n\n\n\nYour Swift Apache module doesn't need to concern itself with the database type\nor connection, it can just ask Apache for a connection and it'll happily\nreturn one from its pool.\nThe code looks like this:\n\n\nguard let con = req.dbdAcquire()                 else { return ... }\nguard let res = con.select(\"SELECT * FROM pets\") else { return ... }\n\nwhile let row = res.next() {\n  req.puts(\"\nli\n\\(row[0])\n/li\n\")\n}\n\n\n\nSo how does Apache know how to connect and all that? As everything in Apache,\nthe admin can configure that in the apache.conf:\n\n\nIfModule dbd_module\n\n  DBDriver  sqlite3\n  DBDParams \"/var/data/testdb.sqlite3\"\n\n/IfModule\n\n\n\n\nOr to access your favorite OpenGroupware.org database using PostgreSQL:\n\n\nIfModule dbd_module\n\n  DBDriver pgsql\n  DBDParams \"host=127.0.0.1 port=5432 dbname=OGo user=OGo password=OGo\"\n\n  # Connection Pool Management\n  DBDMin      1\n  DBDKeep     2\n  DBDMax     10\n  DBDExptime 60\n\n/IfModule\n\n\n\n\nYou get the idea. We provide a simple wrapper for the select query shown as\npart of our \nApache\n module.", 
            "title": "SQL Database Access"
        }, 
        {
            "location": "/mod_dbd/#database-access-using-mod_dbd", 
            "text": "A feature of Apache 2 known to few is mod_dbd .\nUsing that you can configure a SQL database connection within the  Apache.conf \nand use that within all your Apache modules/handlers.  Note : Shown below is pretty raw access to mod_dbd as provided by the\n          mod_swift  Apache  wrapper\n          module.\n          You can use  ApacheExpress  to access\n          databases using the  ZeeQL  library,\n          which is way more convenient.  This will setup a directory as a barebones Swift Apache module (try ApacheExpress for a higher level API!)  Though you can also write your own, Apache 2 comes with drivers for  SQLite3 ,  PostgreSQL ,\nMySQL and Oracle.\nThe macOS system Apache and the one than can be tapped in Homebrew\nincludes SQLite3.\nOn Linux you can easily install the ones you want:  sudo apt-get install libaprutil1-dbd-sqlite3 libaprutil1-dbd-pgsql  Your Swift Apache module doesn't need to concern itself with the database type\nor connection, it can just ask Apache for a connection and it'll happily\nreturn one from its pool.\nThe code looks like this:  guard let con = req.dbdAcquire()                 else { return ... }\nguard let res = con.select(\"SELECT * FROM pets\") else { return ... }\n\nwhile let row = res.next() {\n  req.puts(\" li \\(row[0]) /li \")\n}  So how does Apache know how to connect and all that? As everything in Apache,\nthe admin can configure that in the apache.conf:  IfModule dbd_module \n  DBDriver  sqlite3\n  DBDParams \"/var/data/testdb.sqlite3\" /IfModule   Or to access your favorite OpenGroupware.org database using PostgreSQL:  IfModule dbd_module \n  DBDriver pgsql\n  DBDParams \"host=127.0.0.1 port=5432 dbname=OGo user=OGo password=OGo\"\n\n  # Connection Pool Management\n  DBDMin      1\n  DBDKeep     2\n  DBDMax     10\n  DBDExptime 60 /IfModule   You get the idea. We provide a simple wrapper for the select query shown as\npart of our  Apache  module.", 
            "title": "Database Access using mod_dbd"
        }, 
        {
            "location": "/links/", 
            "text": "Apache Link Collection\n\n\nThere is plenty of information on the Interwebs about \n\"The Number One HTTP Server On The Internet\":\n\n\nOfficial Apache Documentation\n\n\n\n\nThe Apache HTTP Server Project\n\n\nUser Guide\n\n\nConfiguration Quick Reference\n\n\nDeveloper Documentation\n\n\nC Module Development Intro\n\n\n\n\n\n\n\n\nBooks\n\n\n\n\nThe Apache Modules Book\n\n\n\n\nSwift Apache Frameworks\n\n\n\n\nmod_swift\n\n\nApacheExpress\n\n\n\n\nHTTP/2\n\n\n\n\nhow to h2 in apache", 
            "title": "Link Collection"
        }, 
        {
            "location": "/links/#apache-link-collection", 
            "text": "There is plenty of information on the Interwebs about \n\"The Number One HTTP Server On The Internet\":", 
            "title": "Apache Link Collection"
        }, 
        {
            "location": "/links/#official-apache-documentation", 
            "text": "The Apache HTTP Server Project  User Guide  Configuration Quick Reference  Developer Documentation  C Module Development Intro", 
            "title": "Official Apache Documentation"
        }, 
        {
            "location": "/links/#books", 
            "text": "The Apache Modules Book", 
            "title": "Books"
        }, 
        {
            "location": "/links/#swift-apache-frameworks", 
            "text": "mod_swift  ApacheExpress", 
            "title": "Swift Apache Frameworks"
        }, 
        {
            "location": "/links/#http2", 
            "text": "how to h2 in apache", 
            "title": "HTTP/2"
        }, 
        {
            "location": "/about/", 
            "text": "Apache modules in Swift\n.\n\n\nContact\n\n\nHey, we love feedback. Join the mailing list, Slack channel or just drop us\nan email to tell us why this is crap (or not?).\n\n\n\n\nMailing List\n\n\nSlack\n\n\ninfo@mod-swift.org\n\n\n\n\nMkdocs\n\n\nBuilt with \nMkDocs\n \nusing a \ntheme\n \nprovided by \nRead the Docs\n.\n\n\nWho\n\n\nmod_swift is brought to you by the\n\nZeeZide\n GmbH.\n\nImprint\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#contact", 
            "text": "Hey, we love feedback. Join the mailing list, Slack channel or just drop us\nan email to tell us why this is crap (or not?).   Mailing List  Slack  info@mod-swift.org", 
            "title": "Contact"
        }, 
        {
            "location": "/about/#mkdocs", 
            "text": "Built with  MkDocs  \nusing a  theme  \nprovided by  Read the Docs .", 
            "title": "Mkdocs"
        }, 
        {
            "location": "/about/#who", 
            "text": "mod_swift is brought to you by the ZeeZide  GmbH. Imprint .", 
            "title": "Who"
        }
    ]
}